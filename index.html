<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Kutuzov</title>
	<script>
		if (
			!window.File ||
			!window.FileReader ||
			!window.Blob
		) {
			alert('Your browser incompatible with Kutuzov. No luck.');
		}
	</script>
	<style>
		#output{width:100%;text-align:center;font-size:24px;margin:20px 0;}
		#controls{display:none;}
	</style>
</head>
<body>
	<input id="file" name="file" type="file" />

	<label for="settings-wpm">words per minute</label>
	<input id="settings-wpm" name="wpm" type="text" value="500" size="4" maxlength="4" />

	<label for="settings-align">text align</label>
	<select id="settings-align" name="align">
		<option value="center">center</option>
		<option value="left">left</option>
		<option value="right">right</option>
	</select>

	<label for="settings-chunk-size">chunk size</label>
	<input id="settings-chunk-size" name="chunkSize" type="text" value="1" size="1" maxlength="1" />

	<label for="settings-font-size">font size</label>
	<input id="settings-font-size" name="fontSize" type="text" value="24" size="3" maxlength="3" />

	<div id="output"></div>
	<div id="controls">
		<button id="play">&gt; play</button>
		<button id="pause">|| pause</button>
	</div>

	<script>
		document.getElementById('file').addEventListener('change', handleFileSelect, false);
		document.getElementById('play').addEventListener('click', handlePlayClick, false);
		document.getElementById('pause').addEventListener('click', handlePauseClick, false);

		document.body.addEventListener('keypress', handleKeyPress, false);

		document.getElementById('settings-wpm').addEventListener('change', handleSettingsChange, false);
		document.getElementById('settings-align').addEventListener('change', handleSettingsChange, false);
		document.getElementById('settings-chunk-size').addEventListener('change', handleSettingsChange, false);
		document.getElementById('settings-font-size').addEventListener('change', handleSettingsChange, false);

		config = new ktzConfig();
		ktzState.wpm = config.wpm;
		ktzState.align = config.align;
		ktzState.chunkSize = config.chunkSize;
		ktzState.fontSize = config.fontSize;

		// when settings changed
		function handleSettingsChange(ev) {
			ktzState.wpm = parseInt(document.getElementById('settings-wpm').value);
			ktzState.align = document.getElementById('settings-align').value;
			ktzState.fontSize = parseInt(document.getElementById('settings-font-size').value);
			ktzState.chunkSize = parseInt(document.getElementById('settings-chunk-size').value);

			applySettings();
		}

		// read settings from ktzState and apply it to player
		function applySettings() {
			console.log('apply new settings');

			// apply wpm: restart required if in play mode
			if (ktzState.mode == 'play') {
				console.log('apply new wpm in play mode');

				switchMode('pause');
				switchMode('play');
			}

			// apply style settings (font size and text align)
			document.getElementById('output').style.textAlign = ktzState.align;
			document.getElementById('output').style.fontSize = ktzState.fontSize.toString() + "px";
		}

		// when user presses keyboard key
		function handleKeyPress(ev) {
			switch (ev.keyCode) {
				// space: play/pause
				case 32:
					if (ktzState.mode == 'play') {
						switchMode('pause');
					} else if (ktzState.mode == 'pause') {
						switchMode('play');
					}

					break;
			}
		}

		// when user selects file
		function handleFileSelect(ev) {
			var file = ev.target.files[0]

			if (!file) {
				console.log('no file selected');
				return;
			}

			if (file.type != 'text/plain') {
				alert('Kutuzov can\'t see anything except old plain text files.');
				return;
			}

			console.log('position reset [file select]');
			ktzState.pos = 0;

			var reader = new FileReader();
			reader.onloadend = function(ev) { handleFileLoad(ev, reader) };
			reader.readAsText(file);
		}

		// when file load ends
		function handleFileLoad(ev, reader) {
			ktzState.text = reader.result;
			switchMode('play');
		}

		// play loaded text file
		function play() {
			var config = new ktzConfig();
			var container = document.getElementById('output');
			var iterator = new ktzIterator(ktzState.text.split(/\s+/), 0);
			var drawer = new ktzDrawer(iterator, container);

			ktzState.interval = setInterval(function () {
					if (!drawer()) {
						clearInterval(ktzState.interval);
						switchMode('select');
						console.log('cleared');
					}
			}, 60 / ktzState.wpm * 1000);
		}

		// when user clicks play button
		function handlePlayClick(ev) {
			switchMode('play');
		}

		// when user clicks pause button
		function handlePauseClick(ev) {
			switchMode('pause');
		}

		// switch between modes (play, pause, select file etc)
		function switchMode(mode) {
			switch(mode) {
				case 'play':
					document.getElementById('controls').style.display = 'block';
					document.getElementById('play').style.display = 'none';
					document.getElementById('pause').style.display = 'block';
					play();
					ktzState.mode = 'play';
					break;
				case 'pause':
					document.getElementById('controls').style.display = 'block';
					document.getElementById('play').style.display = 'block';
					document.getElementById('pause').style.display = 'none';
					clearInterval(ktzState.interval);
					ktzState.mode = 'pause';
					break;
				case 'select':
					document.getElementById('controls').style.display = 'none';
					ktzState.mode = 'select';
					break;
			}
		}

		// handles persistent settings
		function ktzConfig() {
			// play speed in words per minute
			this.wpm = 500;

			// text align inside container
			this.align = 'center';

			// font size
			this.fontSize = 24;

			// chunk size (how many words to be displayed in one frame)
			this.chunkSize = 1;
		}

		// handles session settings (temporary, in-memory storage)
		function ktzState() {
		}

		// loops through loaded text and gets the next chunk
		function ktzIterator(arr) {
			this.arr = arr;
			this.len = arr.length;

			if (ktzState.pos == undefined) {
				console.log('position reset [undefined]');
				ktzState.pos = 0;
			}

			this.next = function() {
				if (ktzState.pos >= this.len) {
					ktzState.pos = 0;
					console.log('position reset [length exceeded]');
					console.log('reached the end');
					return false;
				}

				var result = this.arr.slice(ktzState.pos, ktzState.pos + ktzState.chunkSize).join(' ');

				console.log('pos ' + ktzState.pos + ' chunk size ' + ktzState.chunkSize);

				ktzState.pos = ktzState.pos + ktzState.chunkSize;

				console.log('chunk ' + result);

				return result;
			}
		}

		// fills output container with current chunk of data
		function ktzDrawer(iterator, container) {
			return function () {
				word = iterator.next();

				if (word == false) {
					return false;
				}

				container.textContent = word;

				return true;
			}
		}
	</script>
</body>
</html>
